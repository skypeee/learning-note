# 嵌入式中的内存布局与堆栈（复习笔记）

## 一、整体内存布局（逻辑视角）

```text
高地址
┌───────────────┐
│ 栈 stack      │  ← 向低地址增长
├───────────────┤
│ 空闲空间      │
├───────────────┤
│ 堆 heap       │  ← 可能向高地址增长（不绝对）
├───────────────┤
│ .bss 段       │  未初始化 / 初始化为 0 的全局变量
├───────────────┤
│ .data 段      │  已初始化的全局 / static 变量
├───────────────┤
│ .text 段      │  程序代码
└───────────────┘
低地址
```

> ⚠️ 这是**逻辑模型**，真实布局由 **链接脚本（linker script）** 决定，尤其在嵌入式中不一定“堆栈相向增长”。

---

## 二、PC vs 嵌入式 MCU 的本质区别

### 1️⃣ PC（x86 / Linux / Windows）

* 程序从 **硬盘** 加载到 **RAM**
* `.text / .data / .bss / heap / stack` **全部在 RAM 中运行**
* RAM 同时承担：

  * 存储介质
  * 运行空间

📌 特点：

* RAM 大
* 有 MMU / 虚拟内存
* malloc / new 成本可接受

---

### 2️⃣ 嵌入式 MCU（STM32 / Cortex-M）

| 存储器   | 特点              | 适合存放          |
| ----- | --------------- | ------------- |
| Flash | 非易失、掉电不丢、运行时不可写 | 程序代码、常量、初始化数据 |
| RAM   | 易失、速度快、可读写      | 变量、栈、堆        |

👉 **代码与数据必须分开存放**。

---

## 三、各内存段的作用与存放策略

### 1️⃣ `.text` —— 代码段

| 项目      | 内容        |
| ------- | --------- |
| 烧录后存储位置 | Flash     |
| 运行时位置   | Flash（通常） |
| 特点      | 只读、不修改    |

✔ Flash 足够快，且节省宝贵 RAM。

⚠️ **重要补充**：

* 少量对时序敏感或 Flash 不可读写期间执行的代码，可能被放到 **RAM 中运行**
* 常见场景：

  * Flash 擦写期间
  * 电机控制 / DSP / 中断热点代码

```c
__attribute__((section(".ramfunc")))
void fast_func(void) {
}
```

---

### 2️⃣ `.data` —— 已初始化数据段

| 项目      | 内容              |
| ------- | --------------- |
| Flash 中 | 存放变量的**初始值**    |
| RAM 中   | 运行时的变量本体        |
| 启动过程    | 从 Flash 拷贝到 RAM |

示例：

```c
int g_val = 10;  // .data
```

📌 原因：

* 变量运行时必须可修改 → 放 RAM
* 初始值不能丢 → 保存在 Flash

---

### 3️⃣ `.bss` —— 未初始化数据段

| 项目    | 内容           |
| ----- | ------------ |
| 变量特征  | 未初始化或初始化为 0  |
| Flash | **不占存储数据空间** |
| RAM   | 占用空间，启动时清零   |

示例：

```c
int counter;      // .bss
static int flag;  // .bss
```

📌 启动阶段：

* 启动代码对 `.bss` 对应的 RAM 区域统一 `memset(0)`

⚠️ 严谨说法：

> `.bss` 不占 Flash 的“数据存储空间”，但在 ELF / 链接信息中仍有段描述

---

## 四、栈（Stack）

### 1️⃣ 栈的基本特性

* **后进先出（LIFO）**
* 自动管理：

  * 函数参数
  * 局部变量
  * 返回地址

✔ 与函数调用的“进入 / 退出”天然匹配。

---

### 2️⃣ 栈的增长方向（Cortex-M）

* **向低地址增长（99% 的现代系统）**

| 操作      | 栈指针变化       |
| ------- | ----------- |
| 入栈 push | SP 减小（地址变低） |
| 出栈 pop  | SP 增大（地址变高） |

```text
高地址  ← 栈底（初始 SP）
│
│   ↓ 向低地址增长
│
低地址  ← 栈顶（当前 SP）
```

---

### 3️⃣ Cortex-M 启动时的栈初始化（关键）

* 向量表：

| 地址          | 内容            |
| ----------- | ------------- |
| 0x0000_0000 | 初始 MSP 值      |
| 0x0000_0004 | Reset_Handler |

👉 CPU 上电后自动：

```text
MSP ← *(0x00000000)
PC  ← *(0x00000004)
```

📌 **栈底地址由链接脚本决定，并写入向量表**。

---

### 4️⃣ 栈溢出（Stack Overflow）

⚠️ **栈溢出 ≠ 一定覆盖堆**

在 MCU（无 MMU）中，可能覆盖：

* `.data / .bss`（全局变量异常）
* 其他任务的栈（RTOS）
* 外设寄存器区 → **HardFault / 直接死机**

📌 工程现象总结：

> 栈溢出常表现为“随机错误、莫名崩溃、变量值异常”

---

## 五、堆（Heap）

### 1️⃣ 堆的用途

* 生命周期 **超出函数作用域** 的数据
* 由程序员控制：

  * `malloc / free`
  * `new / delete`

---

### 2️⃣ 嵌入式中的堆使用原则

✔ **不是“不能用堆”，而是“不用不可控的堆”**

可接受：

* 启动阶段一次性分配
* 固定大小内存池
* 生命周期与系统一致的对象

不推荐：

* 实时路径中频繁 `malloc/free`
* 大小不确定
* 长期运行系统中的碎片化风险

---

### 3️⃣ 碎片与线程安全问题

#### 内存碎片

* 频繁分配 / 释放不同大小内存
* 导致“有空闲但用不了”

#### 线程安全

* 标准 `malloc` 通常加锁
* RTOS / 实时系统中可能成为瓶颈

📌 常见嵌入式对策：

* 固定块内存池
* slab allocator
* FreeRTOS：`heap_4.c` 等方案

---

## 六、重要工程级认知总结（必背）

* PC：RAM = 存储 + 执行
* MCU：

  * Flash = 程序 + 初始值
  * RAM = 可变状态
* 栈：

  * 自动、快速、可预测
  * 空间有限，溢出致命
* 堆：

  * 灵活但不可预测
  * 嵌入式中慎用甚至禁用

> **理解内存布局，是写稳定嵌入式系统的第一道门槛。**
