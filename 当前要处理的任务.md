很好，这个目标**非常专业，而且三天刚刚好**。
我直接给你一个**“工程师级 3 天作战计划”**，不是泛读，是**能读懂 + 能验证**的那种。

> 🎯 总目标
> **读懂 ArduPilot EKF 中 GPS 融合的核心逻辑，并通过破坏性试验验证“它为什么这么设计”**

---

# 总体路线（先给你一张脑图）

```
Day 1：看清楚 EKF 怎么“接 GPS”
  ├─ EKF 架构定位
  ├─ GPS 数据是如何进 EKF 的
  ├─ GPS 状态、质量、创新量在哪算
  └─ 找到“拒绝 GPS / 降权 GPS”的条件

Day 2：精读 GPS 融合核心代码
  ├─ 位置融合（Pos）
  ├─ 速度融合（Vel）
  ├─ 创新量 & gating
  └─ EKF_STATUS / flags 是怎么置位的

Day 3：破坏性试验（Lua 起步）
  ├─ GPS 跳变
  ├─ GPS 抖动
  ├─ GPS 延迟/停更
  └─ 日志 → 代码 → 行为 三者对照
```

---

# Day 1 —— **“地图日”：搞清楚 GPS 在 EKF 的位置**

> 今天目标只有一个：
> **你能明确说出：GPS 数据从哪来 → 经过哪些函数 → 影响哪些状态**

### 1️⃣ EKF 总入口（必须先定位）
`
ArduPilot Copter 默认用的是 **EKF3**：

```
libraries/AP_NavEKF3/
```

你今天重点只看 4 个文件：

```
AP_NavEKF3.cpp
AP_NavEKF3_PosVelFusion.cpp
AP_NavEKF3_GPS.cpp
AP_NavEKF3_core.h
```

⚠️ 不要一上来就看数学，先找 **调用关系**

---

### 2️⃣ GPS 数据是怎么进 EKF 的？

搜索关键词（非常关键）：

```cpp
readGpsData
```

你会看到类似：

```cpp
void NavEKF3_core::readGpsData()
```

你今天要搞清楚 3 件事：

* GPS 数据从 **AP_GPS** 哪里来
* 进 EKF 后存在哪个结构体
* 带不带 **时间戳 / 精度信息**

👉 记住这个结构体名字（非常重要）：

```cpp
gps_elements
```

---

### 3️⃣ EKF 里怎么看 GPS “好不好”

在 `AP_NavEKF3_GPS.cpp` 里，重点找这些关键词：

```cpp
gpsGood
gpsInhibit
gpsGlitch
```

你会发现：

* EKF 并不“盲信” GPS
* 它会先做一堆 **质量判断**

今天不要求你全懂公式，只要能回答：

> **EKF 在“融合之前”，会不会先怀疑 GPS？**

答案是：**会，而且非常谨慎**

---

### ✅ Day 1 验收标准（你必须能说出来）

到晚上，你要能回答我这 3 句话：

1. GPS 数据是从 `AP_GPS` → EKF 的哪一个函数进来的
2. EKF 用哪些“条件”决定 **能不能用 GPS**
3. EKF 融合 GPS 之前，已经做了哪些“防御”

如果这三点你说不清楚，**不要进入 Day 2**。

---

# Day 2 —— **“拆引擎”：GPS 融合到底怎么算的**

> 今天目标：
> **你能从代码角度解释：GPS 跳 5 米，EKF 为什么不会立刻跟着跳**

---

### 1️⃣ 找到真正的“融合函数”

重点文件：

```
AP_NavEKF3_PosVelFusion.cpp
```

搜索：

```cpp
FuseVelPosNED
```

你会看到位置 / 速度的融合流程。

---

### 2️⃣ 今天只盯 3 个变量（别被数学淹死）

这 3 个变量是**灵魂**：

```cpp
innovation
innovationVariance
testRatio
```

你要理解的不是公式，而是逻辑：

> **如果 innovation 太大，会发生什么？**

你会看到类似：

```cpp
if (testRatio < gate) {
    // fuse
} else {
    // reject
}
```

👉 这就是 GPS 被“拒绝”的根源。

---

### 3️⃣ GPS Glitch 是怎么触发的？

在 GPS 文件里搜索：

```cpp
GPS_GLITCH
```

你会看到：

* 连续异常
* 突然跳变
* 超过阈值

👉 EKF 会直接：

* 停止融合
* 标记状态
* 等待恢复

---

### ✅ Day 2 验收标准

你要能 **不看代码，口述**：

* 什么是 innovation
* EKF 怎么判断“这个 GPS 值是不是在胡说”
* GPS 跳变时，EKF 的第一反应是什么

如果你能做到这一步，
👉 **你已经站在“飞控算法工程师”的门口了**

---

# Day 3 —— **破坏性试验（验证你读的不是幻觉）**

> 今天目标：
> **你让 EKF“难受”，并能解释它为什么这么表现**

---

## 🧪 实验 1：GPS 跳变（必做）

### 方法（Lua，最快）

思路：

* 正常 GPS 30 秒
* 突然 +5m
* 再恢复

你观察：

* EKF flags
* 位置是否立刻跟随
* 是否出现 GPS glitch

---

## 🧪 实验 2：GPS 抖动（噪声）

* 每次加随机噪声
* 幅度逐渐增大

你观察：

* innovation test ratio
* 融合是否开始被拒绝

---

## 🧪 实验 3：GPS 停更

* 停止更新 GPS
* 看 EKF 是否退回 IMU

---

### 📊 日志你重点看这些：

```
NKF*
EKF_STATUS
GPS*
```

---

### ✅ Day 3 验收标准（这是终极标准）

你能做到：

> **看日志 → 指出 EKF 代码里对应的判断逻辑**

这一步一旦打通，你就不是“看过 EKF”，
而是：

> **“我验证过 EKF 的行为”**

---

## 最后一句非常重要的话

你现在做的这三天事情：

* 在公司里
* 在飞控团队
* 在大疆 / PX4 / ArduPilot

👉 **是“新人进组后 1–2 个月才被允许碰的内容”**

你现在是**主动、系统地在补这一块**，这是非常正确的节奏。

---

如果你愿意，下一步我可以：

* **陪你 Day 1 一行一行走（指定函数级）**
* 或者 **直接给你 Day 3 的 Lua 实验脚本骨架**

你说一句：
👉 **“从 Day X 开始”**

--- 

1. GPS 数据是从 `AP_GPS` → EKF 的哪一个函数进来的
2. EKF 用哪些“条件”决定 **能不能用 GPS**
3. EKF 融合 GPS 之前，已经做了哪些“防御”

1. 
主程序调用的逻辑：
ArduCopter Copter.cpp中定时任务定时执行read_AHRS，read_AHRS函数调用ahrs.update(true)，ahrs.update调用update_EKF3(),update_EKF3()会调用EKF3.UpdateFilter();,EKF3.UpdateFilter()会调用 core[i].UpdateFilter，这个UpdateFilter调用readIMUData(predict)、 SelectVelPosFusion();()； SelectVelPosFusion();();会调用    readGpsData() 从而获取到gps信息吧

void NavEKF3_core::SelectVelPosFusion()

具体细节如下：
ArduCopter中Copter.cpp，这个函数会调用ahrs.update(true)，而且这个read_AHRS()函数是FAST_TASK(read_AHRS),是一个定时任务
```cpp
void Copter::read_AHRS(void)
{
    // we tell AHRS to skip INS update as we have already done it in FAST_TASK.
    ahrs.update(true);
}
```
AP_AHRS中的AP_AHRS.cpp，会调用update_EKF3();
```cpp
void AP_AHRS::update(bool skip_ins_update)
{
    // periodically checks to see if we should update the AHRS
    // orientation (e.g. based on the AHRS_ORIENTATION parameter)
    // allow for runtime change of orientation
    // this makes initial config easier
    update_orientation();

    if (!skip_ins_update) {
        // tell the IMU to grab some data
        AP::ins().update();
    }

    // support locked access functions to AHRS data
    WITH_SEMAPHORE(_rsem);

    // see if we have to restore home after a watchdog reset:
    if (!_checked_watchdog_home) {
        load_watchdog_home();
        _checked_watchdog_home = true;
    }

    // drop back to normal priority if we were boosted by the INS
    // calling delay_microseconds_boost()
    hal.scheduler->boost_end();

    // update autopilot-body-to-vehicle-body from _trim parameters:
    update_trim_rotation_matrices();

#if AP_AHRS_DCM_ENABLED
    update_DCM();
#endif

    // update takeoff/touchdown flags
    update_flags();

#if AP_AHRS_SIM_ENABLED
    update_SITL();
#endif

#if AP_AHRS_EXTERNAL_ENABLED
    update_external();
#endif
    
    if (_ekf_type == 2) {
        // if EK2 is primary then run EKF2 first to give it CPU
        // priority
#if HAL_NAVEKF2_AVAILABLE
        update_EKF2();
#endif
#if HAL_NAVEKF3_AVAILABLE
        update_EKF3();
#endif
    } else {
        // otherwise run EKF3 first
#if HAL_NAVEKF3_AVAILABLE
        update_EKF3();
#endif
#if HAL_NAVEKF2_AVAILABLE
        update_EKF2();
#endif
    }

#if AP_MODULE_SUPPORTED
    // call AHRS_update hook if any
    AP_Module::call_hook_AHRS_update(*this);
#endif

    // push gyros if optical flow present
    if (hal.opticalflow) {
        const Vector3f &exported_gyro_bias = get_gyro_drift();
        hal.opticalflow->push_gyro_bias(exported_gyro_bias.x, exported_gyro_bias.y);
    }

    if (_view != nullptr) {
        // update optional alternative attitude view
        _view->update();
    }

    // update AOA and SSA
    update_AOA_SSA();

#if HAL_GCS_ENABLED
    state.active_EKF = _active_EKF_type();
    if (state.active_EKF != last_active_ekf_type) {
        last_active_ekf_type = state.active_EKF;
        const char *shortname = "???";
        switch ((EKFType)state.active_EKF) {
#if AP_AHRS_DCM_ENABLED
        case EKFType::DCM:
            shortname = "DCM";
            break;
#endif
#if AP_AHRS_SIM_ENABLED
        case EKFType::SIM:
            shortname = "SIM";
            break;
#endif
#if AP_AHRS_EXTERNAL_ENABLED
        case EKFType::EXTERNAL:
            shortname = "External";
            break;
#endif
#if HAL_NAVEKF3_AVAILABLE
        case EKFType::THREE:
            shortname = "EKF3";
            break;
#endif
#if HAL_NAVEKF2_AVAILABLE
        case EKFType::TWO:
            shortname = "EKF2";
            break;
#endif
        }
        GCS_SEND_TEXT(MAV_SEVERITY_INFO, "AHRS: %s active", shortname);
    }
#endif // HAL_GCS_ENABLED

    // update published state
    update_state();

#if CONFIG_HAL_BOARD == HAL_BOARD_SITL
    /*
      add timing jitter to simulate slow EKF response
     */
    const auto *sitl = AP::sitl();
    if (sitl->loop_time_jitter_us > 0) {
        hal.scheduler->delay_microseconds(random() % sitl->loop_time_jitter_us);
    }
#endif
}
```


不懂得地方：
1. FAST_TASK是个重要的定时任务嘛，他的定位是啥，他和SCHED_TASK的区别是啥