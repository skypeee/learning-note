# 2.Schedulerè°ƒåº¦æœºåˆ¶è§£æ

## ä¸€ã€æ•´ä½“ç›®æ ‡ä¸æ ¸å¿ƒç»“è®º

### ğŸ¯ Day 2 ç›®æ ‡

ç†è§£ ArduPilot ä¸­ï¼š

* `loop()` åˆ°åº•åœ¨å“ªé‡Œ
* é£æ§ä»»åŠ¡æ˜¯å¦‚ä½•**æŒ‰ä¸åŒé¢‘ç‡è¿è¡Œ**
* ä¸ºä»€ä¹ˆé£æ§ä¸ä¼šå› ä¸º delay / é˜»å¡è€Œâ€œå¤±è”â€

---

### âœ… æ ¸å¿ƒç»“è®º

> **ArduPilot é€šè¿‡ AP_Scheduler ç»Ÿä¸€è°ƒåº¦ä»»åŠ¡ï¼ˆä¸»è·¯å¾„ï¼‰ï¼Œ
> å¹¶é¢å¤–é€šè¿‡ delay callback æä¾›â€œå…œåº•å¿ƒè·³â€ï¼Œä¿è¯ç³»ç»Ÿä¸å¤±è”ã€‚**

---

## äºŒã€ç¨‹åºä¸»è°ƒç”¨é“¾ï¼ˆä» main åˆ°è°ƒåº¦å™¨ï¼‰

### 1ï¸âƒ£ ç¨‹åºå…¥å£

ç¨‹åºä» `main()` å¯åŠ¨ï¼Œéšåè¿›å…¥ HAL å±‚è¿è¡Œå¾ªç¯ï¼š

```text
main
 â””â”€ HAL_Linux::run()
```

---

### 2ï¸âƒ£ AP_Vehicle::loopï¼ˆæ ¸å¿ƒå¾ªç¯ï¼‰

åœ¨ `HAL_Linux::run()` ä¸­ï¼Œä¼šè°ƒç”¨ï¼š

```cpp
void AP_Vehicle::loop()
```

å…³é”®ç‚¹ï¼š

* `AP_Vehicle::loop()` è¢«å£°æ˜ä¸º `final`  `void loop() override final;`
* final ä¿®é¥°çš„å‡½æ•° **å­ç±»ï¼ˆå¦‚ Copterï¼‰ä¸èƒ½é‡å†™**
* æ‰€æœ‰é£è¡Œå™¨å…±ç”¨è¿™ä¸€å¥—è°ƒåº¦éª¨æ¶

æºç ç‰‡æ®µï¼ˆç®€åŒ–ï¼‰ï¼š

```cpp
void AP_Vehicle::loop()
{
#if AP_SCHEDULER_ENABLED
    scheduler.loop();
    G_Dt = scheduler.get_loop_period_s();
#else
    hal.scheduler->delay(1);
    G_Dt = 0.001;
#endif
...
...
    run(time_available);
}
```

---

### 3ï¸âƒ£ è¿›å…¥è°ƒåº¦å™¨ï¼šAP_Scheduler

```text
AP_Vehicle::loop
 â””â”€ scheduler.loop()
     â””â”€ scheduler.run()
```

`scheduler.run()` ä¼šéå†å¹¶æ‰§è¡Œï¼š

* `_vehicle_tasks`ï¼ˆæœºå‹ç›¸å…³ä»»åŠ¡ï¼Œå¦‚ Copterï¼‰
* `_common_tasks`ï¼ˆé€šç”¨ä»»åŠ¡ï¼‰

å¹¶ä¸”æ£€æŸ¥å½“å‰ä»»åŠ¡æ˜¯å¦è¶…æ—¶ï¼Œè¶…æ—¶è¿‡å¤šåˆ™ä¼šé™ä½å®šæ—¶ä»»åŠ¡é¢‘ç‡ä»¥æå‡æ¯ä¸ªå‘¨æœŸè¿è¡Œæ—¶é—´ï¼Œæ¥å¤„ç†å»¶æ—¶çš„ä»»åŠ¡
---

## ä¸‰ã€Scheduler çš„ä»»åŠ¡æ¨¡å‹ï¼ˆä¸»è°ƒåº¦è·¯å¾„ï¼‰

### 1ï¸âƒ£ `_common_tasks`ï¼ˆé€šç”¨ä»»åŠ¡ï¼‰

å®šä¹‰ä½ç½®ï¼š

```text
AP_Vehicle/AP_Vehicle.cpp
```

ç¤ºä¾‹ï¼ˆèŠ‚é€‰ï¼‰ï¼š

```cpp
const AP_Scheduler::Task AP_Vehicle::scheduler_tasks[] = {
    SCHED_TASK_CLASS(AP_Notify, &vehicle.notify, update, 50, 300, 78),
    SCHED_TASK(one_Hz_update, 1, 100, 252),
    SCHED_TASK_CLASS(AP_Stats, &vehicle.stats, update, 1, 100, 252),
};
```

ç‰¹ç‚¹ï¼š

* æ˜ç¡®é¢‘ç‡ï¼ˆHzï¼‰
* æ˜ç¡®æ‰§è¡Œé¢„ç®—ï¼ˆtime budgetï¼‰
* **è¿™æ˜¯é£æ§â€œæ­£å¸¸è¿è¡ŒçŠ¶æ€â€çš„è°ƒåº¦æ–¹å¼**

---

### 2ï¸âƒ£ `_vehicle_tasks`ï¼ˆCopter ä¸“å±ä»»åŠ¡ï¼‰

å®šä¹‰ä½ç½®ï¼š

```text
ArduCopter/Copter.cpp
```

é€šè¿‡å‡½æ•°æ³¨å†Œï¼š

```cpp
void Copter::get_scheduler_tasks(...)
```

ç¤ºä¾‹ï¼ˆèŠ‚é€‰ï¼‰ï¼š

```cpp
const AP_Scheduler::Task Copter::scheduler_tasks[] = {
    FAST_TASK(run_rate_controller_main),
    SCHED_TASK(one_hz_loop, 1, 100, 81),
    SCHED_TASK_CLASS(GCS, &_gcs, update_send, 400, 550, 105),
};
```

è¯´æ˜ï¼š

* `FAST_TASK`ï¼šæ¯ä¸ª loop éƒ½ä¼šè·‘ï¼ˆæ§åˆ¶ / IMUï¼‰
* `SCHED_TASK`ï¼šæŒ‰ Hz è°ƒåº¦ï¼ˆ1Hz / 10Hz / 50Hz / 400Hzï¼‰
* **è¿™æ‰æ˜¯é£æ§å®æ—¶æ€§çš„æ ¸å¿ƒæ¥æº**

---

## å››ã€heartbeat


åœ¨æºç ä¸­å¯ä»¥å‘ç°ï¼š

```cpp
GCS_SEND_MESSAGE(MSG_HEARTBEAT);
```

å¹¶ä¸æ˜¯å‡ºç°åœ¨ scheduler task ä¸­ï¼Œè€Œæ˜¯åœ¨ `AP_Vehicle/AP_Vehicle.cpp` çš„ `void AP_Vehicle::scheduler_delay_callback()`ä¸­å‡ºç°çš„ã€‚

---

### âš ï¸ å…³é”®å‘ç°ï¼šscheduler_delay_callback

åœ¨ `AP_Vehicle` åˆå§‹åŒ–è¿‡ç¨‹ä¸­ï¼Œæ³¨å†Œäº†ä¸€ä¸ª delay callbackï¼š

```cpp
hal.scheduler->register_delay_callback(
    scheduler_delay_callback, 5
);
```

å›è°ƒå‡½æ•°ï¼š

```cpp
void AP_Vehicle::scheduler_delay_callback()
{
    if (tnow - last_1hz > 1000) {
        GCS_SEND_MESSAGE(MSG_HEARTBEAT);
        GCS_SEND_MESSAGE(MSG_SYS_STATUS);
    }
}
```

---

### ğŸ§  æ­£ç¡®è®¤çŸ¥

> **scheduler_delay_callback ä¸æ˜¯ä¸»è°ƒåº¦æœºåˆ¶ï¼Œè€Œæ˜¯å…œåº•æœºåˆ¶**

å®ƒçš„ç‰¹ç‚¹ï¼š

* åªåœ¨ `Scheduler::delay()` æœŸé—´è§¦å‘
* ä¸èµ° `scheduler.run()`
* ä¸å— task budget æ§åˆ¶
* åªä¿è¯â€œæœ€ä½é™åº¦çš„å¿ƒè·³å­˜åœ¨â€

---

### âœ… æ­£ç¡®åˆ†å±‚ç†è§£

```text
ã€æ­£å¸¸é£æ§è°ƒåº¦ï¼ˆä¸»è·¯å¾„ï¼‰ã€‘
AP_Vehicle::loop
 â””â”€ scheduler.run
     â”œâ”€ FAST_TASKï¼ˆæ§åˆ¶ / IMUï¼‰
     â”œâ”€ 50Hzï¼ˆGCS / å¯¼èˆªï¼‰
     â”œâ”€ 10Hzï¼ˆç”µæ±  / æ£€æŸ¥ï¼‰
     â””â”€ 1Hzï¼ˆone_hz_loop / housekeepingï¼‰

ã€å…œåº•æœºåˆ¶ï¼ˆå¼‚å¸¸è·¯å¾„ï¼‰ã€‘
Scheduler::delay
 â””â”€ scheduler_delay_callback
     â””â”€ heartbeat / sys_status
```

ğŸ‘‰ **delay callback æ˜¯â€œé˜²å¤±è”ä¿é™©ä¸â€ï¼Œä¸æ˜¯é£æ§ä¸»é€»è¾‘**

---

## äº”ã€Scheduler::delay çš„å·¥ä½œæ–¹å¼ç®€æ

æºç æ ¸å¿ƒé€»è¾‘ï¼š

```cpp
void Scheduler::delay(uint16_t ms)
{
    do {
        microsleep(...);
        if (in_main_thread()) {
            call_delay_cb();
        }
    } while (now < end);
}
```

å…³é”®ç‚¹ï¼š

* å¹¶éå¿™ç­‰
* æ¯æ¬¡ sleep åè°ƒç”¨ delay callback
* ç¡®ä¿åœ¨é˜»å¡æœŸé—´ï¼š

  * GCS ä¸æ–­è”
  * åœ°é¢ç«™ä»èƒ½æ”¶åˆ°å¿ƒè·³

---